= Deps and CLI Guide
Alex Miller
2017-09-08
:type: guides
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

Clojure provides command line tools for:

* Running an interactive REPL (Read-Eval-Print Loop)
* Running Clojure programs
* Evaluating Clojure expressions

Details on how to install the command line tools can be found on the <<getting_started#,Getting Started>> page. A complete reference can be found on the <<xref/../../reference/deps_and_cli#,Deps and CLI>> reference page. Here we will demonstrate how to start working with the command line tools to interact with Clojure and use libraries.

== Running a REPL and using libraries

When you download and install the tools, you can immediately start a REPL by running the `clj` tool:

[source,shell]
----
$ clj
Clojure 1.9.0
user=>
----

Once in the REPL you can type Clojure expressions and press enter to evaluate them.

There are many Clojure and Java libraries available that provide access to practically any functionality you might need. Java includes several libraries for time and date handling, but you might find some code on the Internet for the commonly used Clojure https://github.com/clj-time/clj-time[clj-time] library:

[source,clojure]
----
user=> (require '[clj-time.core :as t])
FileNotFoundException Could not locate clj_time/core__init.class or clj_time/core.clj on classpath.
Please check that namespaces with dashes use underscores in the Clojure file name.
----

The error message indicates that the `clj-time.core` namespace isn't on the JVM's classpath. The classpath specifies all of the places the JVM will look to load Clojure namespaces (or Java classes).

The `clj` tool provides a means to configure which libraries you want to use by creating a configuration file named `deps.edn`. Exit the REPL by typing Ctrl-D at the prompt to return to the terminal.

The deps file declares dependencies as a map from library to coordinate (the version of the library to use). Libraries are published and downloaded from web sites that conform to a well-known layout known as a "Maven repository". Maven repositories identify libraries using a combination of groupId and artifactId which together form a qualified library identifier like `org.clojure/core.async`. Some Clojure libraries (particularly those published in the Clojars repository) use the same name for both. In that case you can just refer to the artifactId without the qualifier: `clj-time` (the fully-qualified `clj-time/clj-time` is also acceptable).
 
Create a file in the current directory named `deps.edn`. This file is in the https://github.com/edn-format/edn[edn] data format, which is a subset of Clojure syntax. It contains a map with the well-known key `:deps` which is a map from library to coordinate:

[source,clojure]
----
{
 :deps {
   clj-time nil
 }
}
----

The coordinate can be used to specify a version. Here we have used `nil` to leave the coordinate blank - this tells the `clj` tool to find the newest version available.

We could also select a specfic version by using a Maven version coordinate:

[source,clojure]
----
{ 
 :deps {
   clj-time {:mvn/version "0.14.2"}
 }
}
----

Restart the REPL and try again:

[source,clojure]
----
$ clj
Clojure 1.9.0
user=> (require '[clj-time.core :as t])
nil
user=> (str (t/now))
"2017-12-06T19:36:56.159Z"
----

You can use the same process to add other libraries to your `deps.edn` file and explore Clojure or Java libraries.

== Writing a program

Soon you may want to start building and saving your own code that makes use of these libraries. Consider the following program that uses clj-time:

[source,clojure]
----
(ns hello.world
  (:require [clj-time.core :as t]
            [clj-time.format :as f]))

(defn time-str
  "Returns a string representation of a datetime in the local time zone."
  [dt]
  (f/unparse
    (f/with-zone (f/formatter "hh:mm aa") (t/default-time-zone))
    dt))

(defn -main []
  (println "Hello world, the time is" (time-str (t/now))))
----

Following common conventions we'll create a `src` directory, and then create a subdirectory for each namespace segment, except for the last which becomes a `.clj` file. This file should thus be saved at `src/hello/world.clj`.

We should also update our `deps.edn` file to include the source path:

[source,clojure]
----
{
 :paths ["src"]
 :deps {
   clj-time {:mvn/version "0.14.2"}
 }
}
----

The program is in the namespace `hello` and has a static entry point named `-main` that is suitable for external invocation. You can run this program using the `clj` tool like this:

[source,shell]
----
$ clj
Clojure 1.9.0
user=> (use 'hello.world)
nil
user=> (-main)
Hello world, the time is 02:03 PM
----

The `clj` tool can act as a Clojure program launcher by running the `-main` function of a namespace with the `-m` option:

[source,shell]
----
$ clj -m hello.world
Hello world, the time is 02:04 PM
----

And finally, the `clj` tool can also evaluate one or more expressions directly from the command line:

[source,shell]
----
$ clj -e "(use 'hello.world) (-main)"
Hello world, the time is 02:05 PM
----

== Using local libraries

After a while you might decide to break a reusable library out of this application. The `clj` tool uses local coordinates to support projects that exist only on your local disk. Let's extract the clj-time parts of this application out into a library called hello/time.

In a new directory, use the deps.edn file you already have, and create a file `src/hello/time.clj`:

[source,clojure]
----
(ns hello.time
  (:require [clj-time.core :as t]
            [clj-time.format :as f]))

(defn now
  "Returns the current datetime"
  []
  (t/now))

(defn time-str
  "Returns a string representation of a datetime in the local time zone."
  [dt]
  (f/unparse
    (f/with-zone (f/formatter "hh:mm aa") (t/default-time-zone))
    dt))
----

Then our application is reduced to:

[source,clojure]
----
(ns hello.world
  (:require [hello.time :as ht]))

(defn -main []
  (println "Hello world, the time is" (ht/time-str (ht/now))))
----

To create the dependency on the other local project, create a new `deps.edn`:

[source,clojure]
----
{
 :paths ["src"]
 :deps {
   hello/time {:local/root "../time"}
 }
}
----

Where the local coordinate refers to the root directory of the hello/time library.

You can then test everything by running the application:

[source,shell]
----
clj -m hello.world
Hello world, the time is 02:07 PM
----

As your program gets more involved you might need to create variations on the standard classpath. The Clojure tools support these using aliases, which are parts of the deps file that are only used when the corresponding alias is supplied. Some of the things you can do are:

* <<deps_and_cli#extra_paths,Include a test source directory>>
* <<deps_and_cli#extra_deps,Add an optional dependency>>
* <<deps_and_cli#override_deps,Override a dependency version>>
* <<deps_and_cli#local_jar,Use a local jar on disk>>

== Other examples

[[extra_paths]]
=== Include a test source directory

Typically, the project classpath includes only the project source, not its test source by default. You can add extra paths as modifications to the primary classpath in the make-classpath step of the classpath construction. To do so, add an alias `:test` that includes the extra relative source path `"test"`:

[source,clojure]
----
{
 :deps {
   org.clojure/core.async {:mvn/version "0.3.465"}
 }
 :aliases {
   :test {:extra-paths ["test"]}
 }
}
----

Apply that classpath modification and examine the modified classpath by invoking `clj -C:test -Spath`:

[source,shell]
----
$ clj -C:test -Spath
src:
test:
/Users/me/.m2/repository/org/clojure/clojure/1.9.0/clojure-1.9.0.jar:
/Users/me/.m2/repository/org/clojure/tools.analyzer/0.6.9/tools.analyzer-0.6.9.jar:
... same as before
----

Note that the test dir is now included in the classpath.

[[extra_deps]]
=== Add an optional dependency

Aliases in the `deps.edn` file can also be used to add optional dependencies that affect the classpath:

[source,clojure]
----
{
 :aliases {
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}
 }
}
----

Here the `:bench` alias is used to add an extra dependency, namely the criterium benchmarking library.

You can add this dependency to your classpath by adding the `:bench` alias to modify the dependency resolution: `clj -R:bench`.

[[override_deps]]
=== Override a dependency

You can use multiple aliases in combination. For example this `deps.edn` file defines two aliases - `:old-async` to force the use of an older core.async version and `:bench` to add an extra dependency:

[source,clojure]
----
{
 :deps {
   org.clojure/core.async {:mvn/version "0.3.465"}
 }
 :aliases {
   :old-async {:override-deps {org.clojure/core.async {:mvn/version "0.3.426"}}}
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}
 }
}
----

Activate both aliases as follows: `clj -R:bench:old-sync`.

[[local_jar]]
=== Include a local jar on disk

Occasionally you may need to refer directly to a jar on disk that is not present in a Maven repository, such as a database driver jar.

Specify local jar dependencies with a local coordinate that points directly to a jar file instead of a directory:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
   oracle/driver {:local/root "/path/to/db/driver.jar"}
 }
}
----
