= Deps and CLI Guide
Alex Miller
2017-09-08
:type: guides
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

Clojure 1.9 introduces a new command-line script (`clojure`) and a wrapper (`clj`) designed for use at the terminal. These scripts use configuration files to construct (and cache) a classpath and then invoke <<xref/../../reference/repl_and_main#,clojure.main>> which can be used as a REPL, expression evaluator, or program runner. For more background on how classpaths are built, see the <<xref/../../reference/deps_and_cli#,Deps and CLI>> reference page.

Dependencies can be declared as:

* Maven artifacts (including support for version, classifier, exclusions, etc) in either public repos or AWS S3 repos
* Local projects on disk (currently only those that also use deps.edn manifests)
* Local jars

Aliases can be specified to indicate different dependency resolution or classpath modifications:

* Add extra deps
* Override dep versions
* Specify default dep versions
* Add extra source directory paths
* Override selected dep locations

In combination, these features provide a set of composable functionality that can be used to manage the variety of possible classpaths to use in a project.

== Configuration

=== Configuration files

The configuration file format (in "deps.edn" files) is an edn map as described above: a map with top-level keys for `:deps`, `:paths`, and `:aliases`, plus provider-specific keys for configuring dependency sources.

After installation, deps.edn configuration files can be found in (up to) three locations:

- installation directory - created and modified only at install time
- config directory (often ~/.clojure) - modified by you to change cross-project (or no-project) defaults
- the local directory - for per-project settings

The deps.edn files in each of these locations (if they exist) are merged to form one combined dependency configuration. The merge is done in the order above, giving local precedence over config over install. The operation is essentially `merge-with merge`, except for the `:paths` key, where only the last one found is used (they are not combined).

You can run `clj -Sverbose -Spath` to see all of the configuration directories and the final computed classpath.

=== Dependencies

Dependencies are declared in a top level key `:deps` which is a map from library to coordinate. Libraries are symbols of the form <groupID>/<artifactId> or simply <id> if the group and artifact ID are the same.

Coordinates can take several forms depending on the coordinate type:

* Maven coordinate: `{:mvn/version "1.2.3"}`
** Other optional keys: `:classifier`, `:extension`, `:exclusions`
* Local project coordinate: `{:local/root "/path/to/project"}`
** Optional key `:deps/manifest`
*** Specifies the project manifest type
*** Default is to auto-detect the project type (such as `:deps`, `:lein`, `:pom`)
*** Currently only `:deps` is supported
* Local jar: `{:local/root "/path/to/file.jar"}`

This list may expand in the future to cover other coordinate types and other manifest types.

=== Paths

Paths are declared in a top level key `:paths` and is a vector of string paths (typically relative to the project root). These source paths will be included on the classpath.

While dependency sets are merged across all of the configuration files, paths replace paths declared in a prior configuration file (last one wins).

=== Aliases

Aliases are defined in the `:aliases` section of the config file and are used to select sets of modifications to the resolved-deps or make-classpath steps. Aliases for `resolve-deps` modifications are selected with -R (which takes a concatenated list of alias keywords). Aliases for `make-classpath` modifications are selected with -C (also a concatenated list of alias keywords). The modifications from all aliases will be combined by merging in the order specified (last one wins).

So given a deps.edn like:

[source,clojure]
----
{:paths ["src"]
 :deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :1.7 {:override-deps {org.clojure/clojure {:mvn/version "1.7.0"}}}
   :bench {:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}
   :test {:extra-paths ["test"]}
 }
}
----

You can activate all three aliases to create a classpath that switches to an older Clojure version, adds the benchmarking library, and includes the test directory in the classpath to see how it changes the classpath:

[source]
----
clj -R:1.7:bench -C:test -Spath
----

It's up to you to define the dependency and classpath modifications that are useful in your project context. Combine or assemble them in whatever ways are useful to your project.

So far we have been using `clj` with `-Spath`, which just prints the computed classpath. Usually, however, you will omit that and instead the script will invoke clojure.main with the other arguments you specify. By default, clojure.main without args will start a REPL but you can also use `-e` to evaluate an expression, `-m` to call the `-main` in a namespace, or specify a scriptpath or `-` to run a script on stdin.

For more details on clojure.main, see <<xref/../../reference/repl_and_main#,REPL and main>>. For more info on installing and using the scripts, see <<xref/../../reference/deps_and_cli#,Deps and CLI Reference>>.

== Examples

=== Run a REPL from anywhere

To start a repl, you can invoke the `clj` script from anywhere as long as your installation has put the script in your path. Presuming there is no `deps.edn` in the current directory, the `deps.edn` files in the install directory (which includes a default depenendency on Clojure) and the config directory (which starts empty) are used to build the classpath.

The classpath will be cached in the user-level cache directory (location as described in the Installation files and directories above), so after the first invocation this should be pretty fast.

=== Run a REPL and specify libs from Maven

When you want to specify libraries, you'll need to create a `deps.edn` file in the current directory, for example:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
   org.clojure/core.async {:mvn/version "0.3.465"}
 }
}
----

Invoking `clj` will then use the install, config, and local `deps.edn` files, merge them together, build the classpath, download the dependencies if needed, and start the REPL using a classpath for those dependencies. The classpath will be cached under `./cpcache` so subsequent invocations will be faster.

=== Include a test source directory

Typically, the project classpath includes only the project source, not its test source by default. You can add extra paths as modifications to the primary classpath in the make-classpath step of the classpath construction. To do so, add an alias `:test` that includes the extra relative source path `"test"`:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
 }
 :aliases {
   :test {:extra-paths ["test"]}
 }
}
----

Apply that classpath modification and start a REPL by invoking `clj -C:test`.

=== Include a local jar on disk

Occasionally you may need to refer directly to a jar on disk that is not present in a Maven repository. One common example is a database driver jar that is not distributed via Maven.

Specify local jar dependencies with a local coordinate which includes a `:local/root` key. The local artifact provider will detect that this refers to a specific file.

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.9.0-beta2"}
   oracle/driver {:local/root "/path/to/oracle/driver.jar"}
 }
}
----

=== Include a local project on disk

You can also refer to local projects that have not been published to any Maven repository or built into a jar. This can be used to create a network of projects that are still in development.

In this case you refer to the local root directory rather than a particular file. The local artifact provider will automatically detect the manifest file (deps.edn) in that directory and use it to determine the project's dependencies, which may either be local or Maven-based:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.9.0-beta2"}
   my.company/sibling-project {:local/root "/path/to/project"}
 }
}
----

Support for other manifest file types (pom.xml, project.clj, etc) are future possible extensions.

=== Run a Clojure namespace in the current directory

When you invoke `clojure` or `clj`, the classpath is built and `clojure.main` is invoked. `clojure.main` has support for loading a namespace and invoking it's `-main` function with arguments:

`clojure -m my.app 1 2 3`

=== Add an optional dependency

Aliases in the `deps.edn` file can also be used to add optional dependencies that affect the classpath:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}
 }
}
----

Here the `:bench` alias is used to add an extra dependency, namely the criterium benchmarking library.

You can add this dependency to your classpath by adding the `:bench` alias to modify the dependency resolution: `clj -R:bench`.

=== Add an optional dependency and override a dependency

You can use multiple aliases in combination. For example this `deps.edn` file defines two aliases - `:1.9` to force the use of a particular Clojure version and `:bench` to add an extra dependency:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}
 }
}
----

Activate both aliases as follows: `clj -R:bench:1.9`

=== Override a classpath source

After dependency resolution, the classpath is constructed. You can modify this step to choose a different source for an artifact by using `:classpath-overrides`:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
   :dev {:classpath-overrides {org.clojure/clojure "/Users/me/code/clojure/target/classes"}}
 }
}
----

The `:1.9` alias is a dependency resolution modification and the `:dev` alias is a classpath modification. Use them both together with: `clj -R:1.9 -C:dev`

=== Show classpath

In most of the previous examples we were starting a REPL or running a Clojure program. You can also use `-Spath` to just print the computed classpath and exit:

`clj -Spath`

Note that `-S` can be used in combination with other `clj` options as well.