= Deps and CLI Guide
Alex Miller
2017-09-08
:type: guides
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

== Rationale

Clojure "endeavors to be a general-purpose language suitable in those areas where Java is suitable" (from https://clojure.org/about/rationale[Rationale]). To effectively target the JVM platform, Clojure needs to provide ready access to Java libraries, ideally in a way suited for dynamic development. In practice, this means meeting the JVM platform in two places:

* the classpath used when invoking JVM processes (and/or URLClassLoaders)
* transitive dependency download and resolution from Maven repositories

https://github.com/clojure/tools.deps.alpha[tools.deps.alpha] is a library providing a functional API to access these capabilities. tools.deps.alpha makes it simple and easy to interactively consume JVM libraries, without dragging in unrelated concerns of building programs or project management. (It should also be a useful shared resource for future work on project and build tools.)

The Clojure 1.9 release for the first time requires multiple artifacts to run Clojure (clojure, spec.alpha, and core.specs.alpha) and thus the issues of transitive dependency are now immediately in front of a Clojure user in the first minute. A new script (`clojure`, and a wrapper for interactive use `clj`) is provided by system-specific installers (e.g. brew, apt-get, etc) as a path for getting started with Clojure development.

Maven-artifacts-first orientation of current tooling has created great rigidity and friction for dev processes - making it hard to e.g. work with libs not yet building/publishing artifacts (new users!), work on speculative changes w/o artifacts, working on mutual changes across multiple libs, give control to a 3rd party tool to manage shared dependencies, and to directly leverage git which is now widely used as a source of truth for code lifecycles.

== Consider the Classpath

Our ultimate goal is to build a JVM classpath. The classpath consists of a series of roots, either a directory path or the path to a jar file. Classes (and Clojure files) map via package or namespace to a relative path. For example, the `java.lang.String` class can be found at path `java/lang/String.class` and the `clojure.set` Clojure file can be found at paths `clojure/set.class` (for AOT), `clojure/set.clj`, or `clojure/set.cljc`. When the JVM needs to load one of these files it searches each root for the relative path and loads it if found.

Classpaths are needed any time we start a JVM which covers many different scenarios. We might want to spin up a REPL disconnected from a project, or run a project REPL including external dependencies and project paths, or execute our tests with extra jars and source, etc. We need tools that let us handle all of these cases by composing different operations.

=== Resolving Dependencies

Much of the complexity in building the classpath comes from traversing external dependencies and downloading their artifacts (jar files) for inclusion on the classpath. Maven repositories provide an immutable, append-only, redundant store of named and versioned artifacts, which effectively defines the Java library ecosystem.

However, defining libraries and artifacts only in Maven terms unnecessarily limits us from a Clojure perspective. Clojure doesn't care at all about artifacts, and in fact Clojure doesn't even need source to be "built" at all to be useful. Maven (and build systems that depend solely on and deploy solely to Maven) have entangled dependency management with artifact production. We would like to retain the ability to use Maven artifacts while also not restricting ourselves solely to libraries built and deployed into Maven.

The first step in our classpath building process is to resolve the transitive set of dependencies aka `resolve-deps`. The primary input to this process is a list of immediate dependencies. Dependencies are described using the Maven "coordinates" - the groupID, artifactID, and version that describe a library and allow it to be located in a Maven repository. 

However, we think it is important to separate the groupID and artifactID (which describe which library you care about) and the version, which is really part of resolution process. Thus the intial dependencies are a map of library to coordinate, where a coordinate is a provider-specific representation of the requested version.

[source,clojure]
----
{
  org.clojure/clojure {:mvn/version "1.9.0-beta1"}
  org.clojure/core.cache {:mvn/version "0.6.5"}
}
----

When these are persisted into a configuration (more on that later), they are stored under a top-level `:deps` key:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.9.0-beta1"}
   org.clojure/core.cache {:mvn/version "0.6.5"}
 }
}
----


The `resolve-deps` code will use the library and coordinate to locate and retrieve the metadata for the specified artifact, including its transitive dependencies. The complete operation will walk the transitive dependencies as well, discovering the entire tree (cycles are cut) representing the full transitive dependency set.

Once the tree has been expanded, `resolve-deps` will cut any excluded dependencies (a feature of Maven), resolve incompatible versions (generally by choosing the newest one), then downloading all of the dependent artifacts to some location on disk. Finally, a data structure called a *lib map* is returned:

[source,clojure]
----
{org.clojure/clojure           {:mvn/version "1.8.0"
                                :path ".../clojure-1.8.0.jar"}
 org.clojure/core.cache        {:mvn/version "0.6.5"
                                :path  ".../core.cache-0.6.5.jar"} 
 org.clojure/data.priority-map {:mvn/version "0.0.7"
                                :dependents [org.clojure/core.cache]}}
----

The lib map lists all libraries and their selected coordinate, which will contain a `:path` on disk and a list of dependents that caused it to be included. Here you can see that `data.priority-map` was discovered as a dependency of core.cache.

=== Modifying the dependency set

There are a number of reasons to alter the default transitive dependency set and `resolve-deps` supports a second resolve-args map to provide modifications to the base dependency set.

==== Adding extra dependencies

One of the most obvious cases is where you want to add extra artifacts to the classpath to augment the normal external dependencies. One common use case is to add dependencies for a special kind of test, for example adding a benchmark library like criterium when building a classpath to run some benchmarks. This option can be specified with `:extra-deps` which takes a lib map:

[source,clojure]
----
{:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}
----

==== Overriding the coordinate

In some cases you may wish to override the normal version resolution decision and instead force a specific coordinate version for a library. For example, say you wanted to run a test to see if your application worked with a beta version of Clojure. In this case, rather than modifying the base set of dependencies, you can specify an override:

[source,clojure]
----
{:override-deps {org.clojure/clojure {:mvn/version "1.9.0-beta1"}}}
----

==== Specifying default coordinates

When using multiple projects, you may wish to specify a set of default dependency coordinates to use when no coordinate is specified. These can be provided using `:default-deps`:

[source,clojure]
----
{:default-deps {org.clojure/core.cache {:mvn/version "0.6.4"}}}
----

==== Aliases

One or more of these dependency modifications can be stored in the configuration in a top-level alias map:

[source,clojure]
----
{
 :aliases {
   :benchmark {:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}
   :beta      {:override-deps {org.clojure/clojure {:mvn/version "1.9.0-beta1"}}}
   :defaults  {:default-deps {org.clojure/core.cache {:mvn/version "0.6.4"}}}
 }
}
----

=== Building the classpath

The second step is to actually build the classpath. The primary inputs to this process are the libs map (the result of resolve-deps), the internal paths of the current project (typically directories that specify source paths). The paths are a collection of string paths, represented in the configuration file as:

[source,clojure]
----
{
 :paths ["src"]
}
----

=== Modifying the classpath

In addition to the modifications that can be done in the 





== Persisting dependency configuration



== Examples

=== Running a REPL from anywhere

* Invoke: `clj`
* Given: No deps.edn file in the current directory.
* Result: Start a repl using the default deps file at <install>/deps.edn.

=== Running a REPL using deps.edn in the current directory

* Invoke: `clj`
* Given: A deps.edn file in the current directory.
* Result: Start a repl using the deps.edn file at ./deps.edn.

=== Including a test source directory into a classpath

* Invoke: `clj -C:test`
* Given: A deps.edn file like the one below.
* Result: Start a repl including external deps and a test source directory root.

[source,clojure]
----
;; deps.edn
{:deps {org.clojure/clojure {:mvn/version "1.9.0-alpha20"}}
 :aliases {
   :test {:extra-paths ["test"]}
 }
}
----

=== Running a Clojure namespace in the current directory

* Invoke: `clojure -m my.app 1 2 3`
* Result: Load the my.app namespace and invoke my.app/-main with the arguments `1 2 3`. If a deps.edn file exists, use it, otherwise use the default deps file.

=== Add an optional dependency to your classpath

* Invoke: `clj -R:bench`
* Given: A deps.edn file like the one below.
* Result: Start a repl using the deps and add the extra deps defined by the `:bench` alias.

[source,clojure]
----
;; deps.edn
{:deps {org.clojure/clojure {:mvn/version "1.8.0"}}
 :aliases {:bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}}}
----

=== Add an optional dependency and override a dependency

* Invoke: `clj -R:bench,1.9`
* Given: A deps.edn file like the one below.
* Result: Start a repl using the deps and add the extra deps defined by the `:bench` alias and the override deps defined by the `:1.9` alias.

[source,clojure]
----
;; deps.edn
{:deps {org.clojure/clojure {:mvn/version "1.8.0"}}
 :aliases {:1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0-alpha20"}}}
           :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}}}
----

=== Override a classpath source

* Invoke: `clj -R1.9 -Cdev`
* Given: A deps.edn file like the one below.
* Result: Start a repl using the deps, the override deps defined by the `:1.9` alias, and the classpath override for the dev path.

[source,clojure]
----
;; deps.edn
{:deps {org.clojure/clojure {:mvn/version "1.8.0"}}
 :aliases {:1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0-alpha20"}}}
           :dev {:classpath-overrides {org.clojure/clojure "/Users/me/code/clojure/target/classes"}}}}
----

=== Show classpath

* Invoke `clj -Spath`
* Given: A deps.edn like the one below.
* Result: Computes the classpath and echoes it to stdout

[source,clojure]
----
;; deps.edn
{:deps {:org.clojure/clojure {:mvn/version "1.8.0"}}}
----

Note that `-S` can be combined with other `clj` options as well.

== Glossary

**Library**

An independently-developed chunk of code residing in a directory hierarchy under a root.  We will narrow to those libraries that can be globally named, e.g. `my.namespace/my-lib`.

**Artifact**

A snapshot of a library, captured at a point in time, possibly subjected to some build process, labeled with a version, containing some manifest documenting its dependencies, and packaged in e.g. a jar.

**Dependency**

An expression, at the project/library level, that the declaring library needs the declared library in order to provide some of its functions. Must at least specify library name, might also specify version and other attrs. Actual (functional) dependencies are more fine-grained. 

We would like to support:

* maven artifacts
* unversioned libraries - a file location identifying a jar or directory root
* git coordinates (later)

**Classpath (and roots/paths)**

An ordered list of local 'places' (filesystem directories and/or jars) that will form root paths for searches of requires/imports at runtime, supplied as an argument to Java which controls the semantics. We discourage order-dependence in the classpath, which implies something is duplicated (and thus likely broken).

**Expansion**

Given a set of root dependencies, a full walk of the transitive dependencies.

**Resolution**

Given a collection of root dependencies and additional modifications, creates a fully-expanded dependency tree, then produces a mapping from each library mentioned to a single version to be used that would satisfy all dependents, as well as the local path. We will also include those dependents for each entry. Conflicts arise only if libraries depend on different major versions of a library.

**Classpath creation**

Creates a classpath from a resolved lib-map and optional extra local lib paths. Current plan for lib-map does not provide for control over resulting order.

**Version**

A human numbering system whose interpretation is determined by convention. Usually x.y.z. Must protect against 'semver' interpretation, which allows libraries to break users while keeping the name the same. Ascending by convention - higher numbers are 'later', vague compatibility with lower/earlier.

**Version difference**

This occurs when the dependency expansion contains the same library with more than one "version" specified but where there is a relative ordering (either by number or by SHA etc). Version differences can be resolved by choosing the "later" or "newest" version when that relationship can be established.

**Version conflict**

A version conflict occurs when the dependency expansion contains the same library with more than one "version" such that the best choice cannot be automatically chosen:

* semver version breakage (major version changed)
* github shas that do not contain any common root or ancestry (two shas on different branches for example)
* versions that cross different repos or repo types such that no relative relationship can be established

**Maven Repo**

A repository of library artifacts - e.g. Maven central or Clojars

**Requires and imports**

Mentions in source code of library (sub)components that must be in the classpath in order to succeed. namespace and package/class names are transformed into path components.

== Links

Resources:

* "Dependency Heaven" talk from EuroClojure 2017 - http://cdn.cognitect.com/presentations/2017/dependency_heaven.pdf[slides], https://youtube.com/watch?v=sStlTye-Kjk[video]

Repositories:

* https://github.com/clojure/tools.deps.alpha[tools.deps.alpha] - library for walking dependencies and building classpaths
* https://github.com/clojure/brew-install[brew-install] - the clojure scripts and brew formula

== Frequently Asked Questions

*Are these scripts and tools.deps.alpha done?*

No. There are lots of known gaps and ideas still to implement. But it is useful now. :)

*Is clj a replacement for lein and boot?*

No. The clojure scripts are focused on a) building classpaths and b) launching clojure programs. They do not (and will not) create artifacts, deploy artifacts, etc. 

tools.deps.alpha aims to provide programmatic building blocks for dependency resolution and classpath construction. clj/clojure wraps these into a command-line form that can be used to run Clojure programs. You can compose these pieces to do many other things.

*Do these scripts allow you to dynamically add dependencies to a running repl?*

No. Other tools exist to do this now or could be added on top of the existing functionality but this was not part of the initial goal.

