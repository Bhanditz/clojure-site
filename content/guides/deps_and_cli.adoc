= Deps and CLI Guide
Alex Miller
2017-09-08
:type: guides
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

Clojure 1.9 introduces a new command-line script (`clojure`) and a wrapper (`clj`) designed for use at the terminal. These scripts use configuration files to construct (and cache) a classpath and then invoke <<xref/../../reference/repl_and_main#,clojure.main>> which can be used as a REPL, expression evaluator, or program runner. For more detail, see the <<xref/../../reference/deps_and_cli#,Deps and CLI>> reference page.

Dependencies can be declared as:

* Maven artifacts (including support for version, classifier, exclusions, etc) in either public repos or AWS S3 repos
* Local projects on disk (currently only those that also use deps.edn manifests)
* Local jars

Aliases can be specified to indicate different dependency resolution or classpath modifications:

* Add extra deps
* Override dep versions
* Specify default dep versions
* Add extra source directory paths
* Override selected dep locations

In combination, these features provide a set of composable functionality that can be used to manage the variety of possible classpaths to use in a project.

Details on how to install the scripts can be found on the <<getting_started#,Getting Started>> page - these will be updated as we add support for more platforms.

== Running a REPL

When you initially download and install the scripts, you immediately have the ability to start a REPL anywhere by simply running `clj` which drops you into a REPL:

[source,shell]
----
$ clj
Clojure 1.9.0
user=>
----

The `clj` script is a wrapper for `clojure` that adds terminal editing support via `rlwrap` so you can up-arrow to repeat a former command, go backwards and forwards and edit in a line, etc (details may vary on your machine based on configuration).

When you run either script, a classpath will be computed based on all of the `deps.edn` files in scope, specfically: the install directory, the config directory, and the current directory. Since you initially won't have a deps.edn in your current directory, and the config one is empty, the dependencies included on your classpath will be entirely based on the install-level deps.edn which looks something like this:

[source,clojure]
----
{
  :paths ["src"]

  :deps {
    org.clojure/clojure {:mvn/version "1.9.0"}
  }

  :aliases {
    :deps {:extra-deps {org.clojure/tools.deps.alpha {:mvn/version "0.2.183"}}}
    :test {:extra-paths ["test"]}
  }

  :mvn/repos {
    "central" {:url "https://repo1.maven.org/maven2/"}
    "clojars" {:url "https://repo.clojars.org/"}
  }
}
----

You can use `clj -Spath` to print the path instead of running `clojure.main`:

[source,shell]
----
$ clj -Spath
src:
/Users/me/.m2/repository/org/clojure/clojure/1.9.0/clojure-1.9.0.jar:
/Users/me/.m2/repository/org/clojure/spec.alpha/0.1.143/spec.alpha-0.1.143.jar:
/Users/me/.m2/repository/org/clojure/core.specs.alpha/0.1.24/core.specs.alpha-0.1.24.jar
----

For the purposes of readability, line breaks were added to the response above between each classpath element. You can see that the classpath includes the "src" directory (due to the `:paths` key), the Clojure jar (due to the `:deps`), and two additional transitive dependencies of Clojure that are found and included as well.

If these jars were not already present on your system you will see additional lines in the first invocation of `clj` showing the jars being downloaded to the Maven repository cache (in ~/.m2/repository).

The `clj` script not only computes and uses the classpath but also caches it in the user-level cache directory (often at ~/.clojure/.cpcache when there is no local deps.edn). This caching means that spinning up a Clojure repl can be done without re-computing the classpath or downloading any libraries.

== Running a REPL with libraries from Maven

When you want to specify libraries from Maven, you should create a `deps.edn` file in the current directory, probably a project directory. For example, this `deps.edn` file has two dependencies, Clojure and core.async:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
   org.clojure/core.async {:mvn/version "0.3.465"}
 }
}
----

We can run `clj -Spath` to see the computed classpath (again, output separated into lines for readability):

[clojure,shell]
----
$ clj -Spath
src:
/Users/me/.m2/repository/org/clojure/clojure/1.9.0/clojure-1.9.0.jar:
/Users/me/.m2/repository/org/clojure/tools.analyzer/0.6.9/tools.analyzer-0.6.9.jar:
/Users/me/.m2/repository/org/clojure/core.specs.alpha/0.1.24/core.specs.alpha-0.1.24.jar:
/Users/me/.m2/repository/org/clojure/spec.alpha/0.1.143/spec.alpha-0.1.143.jar:
/Users/me/.m2/repository/org/clojure/tools.analyzer.jvm/0.7.0/tools.analyzer.jvm-0.7.0.jar:
/Users/me/.m2/repository/org/clojure/tools.reader/1.0.0-beta4/tools.reader-1.0.0-beta4.jar:
/Users/me/.m2/repository/org/clojure/core.memoize/0.5.9/core.memoize-0.5.9.jar:
/Users/me/.m2/repository/org/clojure/data.priority-map/0.0.7/data.priority-map-0.0.7.jar:
/Users/me/.m2/repository/org/clojure/core.cache/0.6.5/core.cache-0.6.5.jar:
/Users/me/.m2/repository/org/ow2/asm/asm-all/4.2/asm-all-4.2.jar:
/Users/me/.m2/repository/org/clojure/core.async/0.3.465/core.async-0.3.465.jar
----

In addition to the source and the required dependencies, the full transitive dependency graph of these is much larger!

== Including a test source directory

Typically, the project classpath includes only the project source, not its test source by default. You can add extra paths as modifications to the primary classpath in the make-classpath step of the classpath construction. To do so, add an alias `:test` that includes the extra relative source path `"test"`:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
   org.clojure/core.async {:mvn/version "0.3.465"}
 }
 :aliases {
   :test {:extra-paths ["test"]}
 }
}
----

Apply that classpath modification and examine the modified classpath by invoking `clj -C:test -Spath`:

[source,shell]
----
$ clj -C:test -Spath
src:
test:
/Users/me/.m2/repository/org/clojure/clojure/1.9.0/clojure-1.9.0.jar:
/Users/me/.m2/repository/org/clojure/tools.analyzer/0.6.9/tools.analyzer-0.6.9.jar:
... same as before
----

Note that the test dir is now included in the classpath.

== Adding an optional dependency

Aliases in the `deps.edn` file can also be used to add optional dependencies that affect the classpath:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}
 }
}
----

Here the `:bench` alias is used to add an extra dependency, namely the criterium benchmarking library.

You can add this dependency to your classpath by adding the `:bench` alias to modify the dependency resolution: `clj -R:bench`.

== Adding an optional dependency and overriding a dependency

You can use multiple aliases in combination. For example this `deps.edn` file defines two aliases - `:1.9` to force the use of a particular Clojure version and `:bench` to add an extra dependency:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}
 }
}
----

Activate both aliases as follows: `clj -R:bench:1.9`

== Overriding a classpath source

After dependency resolution, the classpath is constructed. You can modify this step to choose a different source for an artifact by using `:classpath-overrides`:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
   :dev {:classpath-overrides {org.clojure/clojure "/Users/me/code/clojure/target/classes"}}
 }
}
----

The `:1.9` alias is a dependency resolution modification and the `:dev` alias is a classpath modification. Use them both together with: `clj -R:1.9 -C:dev`

== Including a local jar on disk

Occasionally you may need to refer directly to a jar on disk that is not present in a Maven repository. One common example is a database driver jar that is not distributed via Maven.

Specify local jar dependencies with a coordinate which includes a `:local/root` key. The local artifact provider will detect that this refers to a specific file.

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
   oracle/driver {:local/root "/path/to/oracle/driver.jar"}
 }
}
----

== Including a local project on disk

You can also refer to local projects that have not been published to any Maven repository or built into a jar. This can be used to create a network of projects that are still in development.

In this case you refer to the local root directory rather than a particular file. The local artifact provider will automatically detect the manifest file (deps.edn) in that directory and use it to determine the project's dependencies, which may either be local or Maven-based:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
   my.company/sibling-project {:local/root "/path/to/project"}
 }
}
----

Support for other manifest file types (pom.xml, project.clj, etc) are future possible extensions.

== Running a Clojure namespace in the current directory

When you invoke `clojure` or `clj`, the classpath is built and `clojure.main` is invoked. `clojure.main` has support for loading a namespace and invoking it's `-main` function with arguments:

`clojure -m my.app 1 2 3`