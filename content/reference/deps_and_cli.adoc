= Deps and CLI
Alex Miller
2017-11-30
:type: reference
:toc: macro
:icons: font
:prevpagehref: lisps
:prevpagetitle: Differences with Lisps

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

== Rationale

Clojure "endeavors to be a general-purpose language suitable in those areas where Java is suitable" (from <<xref/../../about/rationale#,Rationale>>). To effectively target the JVM platform, Clojure needs to provide ready access to Java libraries, ideally in a way suited for dynamic development. In practice, this means meeting the JVM platform in two places:

* the classpath used when invoking JVM processes (and/or URLClassLoaders)
* transitive dependency download and resolution from Maven repositories

https://github.com/clojure/tools.deps.alpha[tools.deps.alpha] is a library providing a functional API to access these capabilities. tools.deps.alpha makes it simple and easy to interactively consume JVM libraries, without dragging in unrelated concerns of building programs or project management. (It should also be a useful shared resource for future work on project and build tools.)

The Clojure 1.9 release for the first time requires multiple artifacts to run Clojure (clojure, spec.alpha, and core.specs.alpha) and thus the issues of transitive dependency are now immediately in front of a Clojure user in the first minute. A new script (`clojure`, and a wrapper for interactive use `clj`) is provided by system-specific installers (e.g. brew, apt-get, etc) as a path for getting started with Clojure development.

Maven-artifacts-first orientation of current tooling has created great rigidity and friction for dev processes - making it hard to e.g. work with libs not yet building/publishing artifacts (new users!), work on speculative changes w/o artifacts, working on mutual changes across multiple libs, give control to a 3rd party tool to manage shared dependencies, and to directly leverage git which is now widely used as a source of truth for code lifecycles.

== Building the Classpath

Our ultimate goal is to build a JVM classpath. The classpath consists of a series of roots, either a directory path or the path to a jar file. Classes (and Clojure files) map via package or namespace to a relative path. For example, the `java.lang.String` class can be found at path `java/lang/String.class` and the `clojure.set` Clojure file can be found at paths `clojure/set.class` (for AOT), `clojure/set.clj`, or `clojure/set.cljc`. When the JVM needs to load one of these files it searches each root for the relative path and loads it if found.

Classpaths are needed any time we start a JVM which covers many different scenarios. We might want to spin up a REPL disconnected from a project, or run a project REPL including external dependencies and project paths, or execute our tests with extra jars and source, etc. We need tools that let us handle all of these cases by composing different operations.

We divide the process of building a classpath into two primary operations: `resolve-deps` and `make-classpath`. Below is a high-level view of this process:

image:/images/content/guides/deps/cp.jpg["Classpath Process",height="300"]

=== resolve-deps

Much of the complexity in building the classpath comes from traversing external dependencies and downloading their artifacts (jar files) for inclusion on the classpath. Maven repositories provide an immutable, append-only, redundant store of named and versioned artifacts, which effectively defines the Java library ecosystem.

However, defining libraries and artifacts only in Maven terms unnecessarily limits us from a Clojure perspective. Clojure doesn't care at all about artifacts, and in fact Clojure doesn't even need source to be "built" at all to be useful. Maven (and build systems that depend solely on and deploy solely to Maven) have entangled dependency management with artifact production. We would like to retain the ability to use Maven artifacts while also not restricting ourselves solely to libraries built and deployed into Maven.

The first step in our classpath building process is to resolve the transitive set of dependencies aka `resolve-deps`. The primary input to this process is a list of immediate dependencies. Dependencies are described using the Maven "coordinates" - the groupID, artifactID, and version that describe a library and allow it to be located in a Maven repository or other provider.

However, we think it is important to separate the groupID and artifactID (the library you care about) from the version, which is really part of resolution process. Thus the intial dependencies are a map of library to coordinate, where a coordinate is a provider-specific representation of the requested version.

[source,clojure]
----
{
  org.clojure/clojure {:mvn/version "1.9.0-beta1"}
  org.clojure/core.cache {:mvn/version "0.6.5"}
}
----

When these are persisted into a configuration (more on that later), they are stored under a top-level `:deps` key:

[source,clojure]
----
{
 :deps {
   org.clojure/clojure {:mvn/version "1.9.0-beta1"}
   org.clojure/core.cache {:mvn/version "0.6.5"}
 }
}
----


The `resolve-deps` code will use the library and coordinate to locate and retrieve the metadata for the specified artifact, including its transitive dependencies. The complete operation will walk the transitive dependencies as well, discovering the entire tree (cycles are cut) representing the full transitive dependency set.

Once the tree has been expanded, `resolve-deps` will remove any excluded dependencies, resolve incompatible versions (generally by choosing the newest one), and download all of the dependent artifacts to disk. Finally, a data structure called a *lib map* is returned:

[source,clojure]
----
{org.clojure/clojure           {:mvn/version "1.8.0"
                                :path ".../clojure-1.8.0.jar"}
 org.clojure/core.cache        {:mvn/version "0.6.5"
                                :path  ".../core.cache-0.6.5.jar"} 
 org.clojure/data.priority-map {:mvn/version "0.0.7"
                                :dependents [org.clojure/core.cache]}}
----

The lib map lists all libraries and their selected coordinates, which will contain a `:path` on disk and a list of dependents that caused it to be included. Here you can see that `data.priority-map` was included as a dependency of core.cache.

There are a number of reasons to alter the default transitive dependency set and `resolve-deps` takes a *resolve-args* map to provide various modifications to the base dependency set and options are available for the three use cases: adding extra dependencies, overriding deps, and default deps.

==== Adding extra dependencies

One modification is to add extra artifacts to the classpath to augment the normal external dependencies. For example, you might want to add a benchmark library like criterium when building a classpath to run some benchmarks. Extra dependencies can be specified with `:extra-deps` which takes a map of library to coordinate:

[source,clojure]
----
{:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}
----

==== Overriding the coordinate

Another possible modification is to override the coordinate version that would be chosen by the default algorithm and force a specific version instead. For example, say you wanted to run a test to see if your application worked with a beta version of Clojure. In this case, rather than modifying the base set of dependencies, you can specify an override:

[source,clojure]
----
{:override-deps {org.clojure/clojure {:mvn/version "1.9.0-beta1"}}}
----

==== Specifying default coordinates

When using multiple projects, you may wish to specify a set of default dependency coordinates to use when no coordinate is specified. These can be provided using `:default-deps`:

[source,clojure]
----
{:default-deps {org.clojure/core.cache {:mvn/version "0.6.4"}}}
----

==== Aliases

Rather than specify these modifications on the command-line, you can instead persist modifications under an alias name:

[source,clojure]
----
{
 :aliases {
   :benchmark {:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}
   :beta      {:override-deps {org.clojure/clojure {:mvn/version "1.9.0-beta1"}}}
   :defaults  {:default-deps {org.clojure/core.cache {:mvn/version "0.6.4"}}}
 }
}
----

This example creates three different aliases (`:benchmark`, `:beta`, and `:defaults`). At the command line you can specify one or more of these to use in combination to alter your classpath.

The output of deps resolution is a map of library to chosen coordinate where each coordinate has a known location on disk. The JVM however needs a classpath and thus the second stage is to actually build the classpath.

=== make-classpath

The primary inputs to this process are the libs map (the result of `resolve-deps`) and the internal paths of the current project (directories that specify source paths). The paths are a collection of string paths, represented in the configuration file as:

[source,clojure]
----
{:paths ["src"]}
----

In addition to the modifications that can be done during deps resolution, there are some modifications that can be performed during this stage as well. Similar to the `resolve-deps` modifications, these can be named and persisted under an alias name.

==== Extra paths

When building a special classpath (the "test" classpath for example), you may want to include additional source paths. These can be added with `:extra-paths` which is a vector of paths, similar to `:paths`:

[source,clojure]
----
{:extra-paths ["test" "resources"]}
----

==== Classpath overrides

You may have an alternate location on disk that can be used to satisfy a particular dependency found during `resolve-deps`. For this, you can use `:classpath-overrides`:

[source,clojure]
----
{:classpath-overrides {org.clojure/clojure {:path "/my/clojure/target"}}}
----

== Installation

For installation, see the instructions in the <<xref/../../guides/getting_started#,Getting Started>> guide.

== Usage

Usage:

* `clojure [dep-opt*] [init-opt*] [main-opt] [arg*]`
* `clj     [dep-opt*] [init-opt*] [main-opt] [arg*]`

The clojure script is a runner for Clojure. clj is a wrapper for interactive repl use. These scripts ultimately construct and invoke a command-line of the form:

`java [java-opt*] -cp classpath clojure.main [init-opt*] [main-opt] [arg*]`

The dep-opts are used to build the java-opts and classpath:

----
-Jopt      Pass opt through in java_opts, ex: -J-Xmx512m
-Ralias... Concatenated resolve-deps aliases, ex: -R:bench:1.9
-Calias... Concatenated make-classpath aliases, ex: -C:dev
-Spath     Compute classpath and echo to stdout only
-Srepro    Use only the local deps.edn (ignore other config files)
-Sforce    Force recomputation of the classpath (don't use the cache)
-Spom      Generate (or update an existing) pom.xml with deps and paths
-Sverbose  Print important path info to console
----

init-opt:

----
-i, --init path     Load a file or resource
-e, --eval string   Eval exprs in string; print non-nil values
----

main-opt:

----
-m, --main ns-name  Call the -main function from namespace w/args
-r, --repl          Run a repl
path                Run a script from a file or resource
-                   Run a script from standard input
-h, -?, --help      Print this help message and exit
----

=== deps.edn

The dependency configuration is stored in files named deps.edn. After installation, deps.edn configuration files can be found in (up to) three locations:

- installation directory - created and modified only at install time
- config directory (often ~/.clojure) - modified by you to change cross-project (or no-project) defaults
- the local directory - for per-project settings
 
The deps.edn file is an instance of the `::deps-map` https://github.com/clojure/tools.deps.alpha/blob/master/src/main/clojure/clojure/tools/deps/alpha/specs.clj[spec]. 

Example:

[source,clojure]
----
{
 ;; Paths in project
 :paths ["src"]

 ;; Project dependencies, a map from lib to coordinate
 :deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
   ring {:mvn/version "1.5.0"}
   hiccup {:mvn/version "1.0.5"}
 }

 ;; Aliases that can be used with -R and -C
 :aliases {
   ;; An alias that adds an extra dep to use for benchmarking: -R:bench
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}

   ;; An alias to override the default Clojure version: -R:1.9
   :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0-beta2"}}}

   ;; A classpath override alias to use a local build of Clojure: -C:dev
   :dev {:classpath-overrides {org.clojure/clojure "/Users/me/clojure/target/classes"}}

   ;; Add extra paths to the classpath: -C:test
   :test {:extra-paths ["test"]}
 }

 ;; Configure Maven repos - these are typical set in the system deps.edn only
 :mvn/repos {
   "central" {:url "https://repo1.maven.org/maven2/"}
   "clojars" {:url "https://clojars.org/repo/"}
 }
}
----

=== Classpath construction

The following process is used to construct the classpath for invoking clojure.main:

* Compute the deps map
** Read the deps.edn configuration file in the following locations:
*** Install directory (unless -Srepro)
*** Config directory (if it exists and unless -Srepro)
*** Current directory (if it exists)
** Combine the deps.edn maps in that order with `merge-with merge` (except for :paths where last wins)
* Compute the resolve-deps args
** If `-R` specifies one or more aliases, find each alias in the deps map `:aliases`
** `merge-with` `merge` the alias maps - the result is the resolve-args map
* Invoke `resolve-deps` with deps map and resolve-args map
* Compute the classpath-overrides map
** If `-C` specifies one or more aliases, find each alias in the deps map `:aliases`
** `merge` the classpath-override alias maps
* Invoke `make-classpath` with the libs map returned by `resolve-deps`, the paths, and the classpath-args map

=== Classpath caching

Classpath files are cached in the current directory under `.cpcache/`. File are of two forms:

* `.cpcache/<hash>.libs` - a `::lib-map` in the https://github.com/clojure/tools.deps.alpha/blob/master/src/main/clojure/clojure/tools/deps/alpha/specs.clj[specs], the output of running `resolve-deps`
* `.cpcache/<hash>.cp` - a classpath string, the output of `make-classpath`

where the `<hash>` is based on the config file paths, the resolve-aliases, and the classpath aliases.

The cached classpath file is used when:

* It exists
* It is newer than all `deps.edn` files

=== Installation files and directories

The `clojure` and `clj` scripts rely on several directories and optionally on several environment variables.

* Installation directory
** Created during installation
** Contents:
*** `bin/clojure` - main script
*** `bin/clj` - wrapper script for interactive repl use (uses `rlwrap`)
*** `deps.edn` - install level deps.edn file, with some default deps (Clojure, etc)
*** `example-deps.edn` - commented example that gets copied to `<config_dir>/deps.edn`
*** `libexec/clojure-scripts-X.Y.Z.jar` - uberjar invoked by `clojure` to construct classpaths
* Config directory
** Can be created to hold a deps.edn file that carries across installation upgrades and takes affect across projects
** Locations checked in this order:
*** If `$CLJ_CONFIG` is set, then use `$CLJ_CONFIG` (explicit override)
*** If `$XDG_CONFIG_HOME` is set, then use `$XDG_CONFIG_HOME/clojure` (follows Freedesktop conventions)
*** Else use `$HOME/.clojure`
** Contents:
*** `deps.edn` - user deps file, defines default Clojure version and provider defaults
* Cache directory
** Lazily created if `clojure` is invoked without a local `deps.edn` file. Locations checked in this order:
*** If `$CLJ_CACHE` is set, then use `$CLJ_CACHE` (explicit override)
*** If `$XDG_CACHE_HOME` is set, then use `$XDG_CACHE_HOME/clojure` (follows Freedesktop conventions)
*** Else use `config_dir/.cpcache`
* Project directory
** The current directory
** Contents:
*** `deps.edn` - optional project deps
*** `.cpcache` - project cache directory, same as the user-level cache directory, created if there is a `deps.edn`

== Connecting to S3 Maven repositories

The clj script includes support for connecting to private S3 Maven repositories (thanks to the https://github.com/s3-wagon-private/s3-wagon-private[s3-wagon-private] and https://github.com/spring-projects/aws-maven[aws-wagon] projects).

=== S3 repository

In your deps.edn file, include the s3 repository root:

[source,clojure]
----
{:deps {
   my.library {:mvn/version "0.1.2"}
 }
 :mvn/repos {
   "my-private-repo" {:url "s3://my-bucket/maven/releases"}
 }
}
----

=== S3 credentials

There are several ways to specify your AWS S3 credentials:

1. Set the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
2. Create a default profile in the AWS credentials file `~/.aws/credentials` (older `~/.aws/config` also supported).
3. Create a named profile in the AWS credentials file and set the environment variable `AWS_PROFILE` with its name.
4. Amazon ECS container and instance profile credentials should also work, but have not been tested.

For more information, most of the advice in http://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html[this AWS document] describes how credentials are located. Note however that the Java system properties options will NOT work with the clojure scripts (but would work if using the tools.deps.alpha library directly).

== Glossary

**Library**

An independently-developed chunk of code residing in a directory hierarchy under a root.  We will narrow to those libraries that can be globally named, e.g. `my.namespace/my-lib`.

**Artifact**

A snapshot of a library, captured at a point in time, possibly subjected to some build process, labeled with a version, containing some manifest documenting its dependencies, and packaged in e.g. a jar.

**Coordinate**

A particular version of a library chosen for use, with information sufficient to obtain and use the library.

**Dependency**

An expression, at the project/library level, that the declaring library needs the declared library in order to provide some of its functions. Must at least specify library name, might also specify version and other attrs. Actual (functional) dependencies are more fine-grained. 

Dependency types:

* maven artifacts
* unversioned libraries - a file location identifying a jar or directory root
* git coordinates (later)

**Classpath (and roots/paths)**

An ordered list of local 'places' (filesystem directories and/or jars) that will form root paths for searches of requires/imports at runtime, supplied as an argument to Java which controls the semantics. We discourage order-dependence in the classpath, which implies something is duplicated (and thus likely broken).

**Expansion**

Given a set of root dependencies, a full walk of the transitive dependencies.

**Resolution**

Given a collection of root dependencies and additional modifications, creates a fully-expanded dependency tree, then produces a mapping from each library mentioned to a single version to be used that would satisfy all dependents, as well as the local path. We will also include those dependents for each entry. Conflicts arise only if libraries depend on different major versions of a library.

**Classpath creation**

Creates a classpath from a resolved lib-map and optional extra local lib paths. Current plan for lib-map does not provide for control over resulting order.

**Version**

A human numbering system whose interpretation is determined by convention. Usually x.y.z. Must protect against 'semver' interpretation, which allows libraries to break users while keeping the name the same. Ascending by convention - higher numbers are 'later', vague compatibility with lower/earlier.

**Version difference**

This occurs when the dependency expansion contains the same library with more than one "version" specified but where there is a relative ordering (either by number or by SHA etc). Version differences can be resolved by choosing the "later" or "newest" version when that relationship can be established.

**Version conflict**

A version conflict occurs when the dependency expansion contains the same library with more than one "version" such that the best choice cannot be automatically chosen:

* semver version breakage (major version changed)
* github shas that do not contain any common root or ancestry (two shas on different branches for example)
* versions that cross different repos or repo types such that no relative relationship can be established

**Maven Repo**

A repository of library artifacts - e.g. Maven central or Clojars

**Requires and imports**

Mentions in source code of library (sub)components that must be in the classpath in order to succeed. namespace and package/class names are transformed into path components.