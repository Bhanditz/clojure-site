= Deps and CLI
Alex Miller
2017-11-30
:type: reference
:toc: macro
:icons: font
:prevpagehref: lisps
:prevpagetitle: Differences with Lisps

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

Clojure 1.9 introduces a new command-line script (`clojure`) and a wrapper script (`clj`) designed for use at the terminal. These scripts use configuration files to construct (and cache) a classpath and then invoke <<repl_and_main#,clojure.main>> which can be used as a REPL, expression evaluator, or program runner. For more background on how classpaths are built, see the <<xref/../../guides/deps_and_cli#,Deps and CLI guide>>.

== Installation

=== Installation on Mac via `brew`

The latest development version of the Clojure scripts can be installed by selecting the `devel` version of Clojure as follows:

[source,shell]
----
brew install --devel clojure
----

If you omit the `--devel` you will instead get the latest stable version of Clojure, currently 1.8.0.

=== Installation on Linux

Package installers are not yet available but the following process can be used to manually install the latest devel version of the `clj` script on a *nix system. First ensure that the following dependencies are installed: curl, rlwrap, and Java. Then use the following commands to download and run the installer script, which will create /usr/local/bin/clj, /usr/local/bin/clojure, and /usr/local/lib/clojure:

[source,shell]
----
curl -O https://download.clojure.org/install/linux-install.sh
chmod +x linux-install.sh
sudo ./linux-install.sh
----

=== Installation on Windows

COMING SOON

== Usage

Usage:

* `clojure [dep-opt*] [init-opt*] [main-opt] [arg*]`
* `clj     [dep-opt*] [init-opt*] [main-opt] [arg*]`

The clojure script is a runner for Clojure. clj is a wrapper for interactive repl use. These scripts ultimately construct and invoke a command-line of the form:

`java [java-opt*] -cp classpath clojure.main [init-opt*] [main-opt] [arg*]`

The dep-opts are used to build the java-opts and classpath:

----
-Jopt      Pass opt through in java_opts, ex: -J-Xmx512m
-Ralias... Concatenated resolve-deps aliases, ex: -R:bench:1.9
-Calias... Concatenated make-classpath aliases, ex: -C:dev
-Spath     Compute classpath and echo to stdout only
-Srepro    Use only the local deps.edn (ignore other config files)
-Sforce    Force recomputation of the classpath (don't use the cache)
-Spom      Generate (or update an existing) pom.xml with deps and paths
-Sverbose  Print important path info to console
----

init-opt:

----
-i, --init path     Load a file or resource
-e, --eval string   Eval exprs in string; print non-nil values
----

main-opt:

----
-m, --main ns-name  Call the -main function from namespace w/args
-r, --repl          Run a repl
path                Run a script from a file or resource
-                   Run a script from standard input
-h, -?, --help      Print this help message and exit
----

=== deps.edn

The dependency configuration is stored in files named deps.edn. After installation, deps.edn configuration files can be found in (up to) three locations:

- installation directory - created and modified only at install time
- config directory (often ~/.clojure) - modified by you to change cross-project (or no-project) defaults
- the local directory - for per-project settings
 
The deps.edn file is an instance of the `::deps-map` https://github.com/clojure/tools.deps.alpha/blob/master/src/main/clojure/clojure/tools/deps/alpha/specs.clj[spec]. 

Example:

[source,clojure]
----
{
 ;; Paths in project
 :paths ["src"]

 ;; Project dependencies, a map from lib to coordinate
 :deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
   ring {:mvn/version "1.5.0"}
   hiccup {:mvn/version "1.0.5"}
 }

 ;; Aliases that can be used with -R and -C
 :aliases {
   ;; An alias that adds an extra dep to use for benchmarking: -R:bench
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}

   ;; An alias to override the default Clojure version: -R:1.9
   :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0-beta2"}}}

   ;; A classpath override alias to use a local build of Clojure: -C:dev
   :dev {:classpath-overrides {org.clojure/clojure "/Users/me/clojure/target/classes"}}

   ;; Add extra paths to the classpath: -C:test
   :test {:extra-paths ["test"]}
 }

 ;; Configure Maven repos - these are typical set in the system deps.edn only
 :mvn/repos {
   "central" {:url "https://repo1.maven.org/maven2/"}
   "clojars" {:url "https://clojars.org/repo/"}
 }
}
----

=== Classpath construction

The following process is used to construct the classpath for invoking clojure.main:

* Compute the deps map
** Read the deps.edn configuration file in the following locations:
*** Install directory (unless -Srepro)
*** Config directory (if it exists and unless -Srepro)
*** Current directory (if it exists)
** Combine the deps.edn maps in that order with `merge-with merge` (except for :paths where last wins)
* Compute the resolve-deps args
** If `-R` specifies one or more aliases, find each alias in the deps map `:aliases`
** `merge-with` `merge` the alias maps - the result is the resolve-args map
* Invoke `resolve-deps` with deps map and resolve-args map
* Compute the classpath-overrides map
** If `-C` specifies one or more aliases, find each alias in the deps map `:aliases`
** `merge` the classpath-override alias maps
* Invoke `make-classpath` with the libs map returned by `resolve-deps`, the paths, and the classpath-args map

=== Classpath caching

Classpath files are cached in the current directory under `.cpcache/`. File are of two forms:

* `.cpcache/<hash>.libs` - a `::lib-map` in the https://github.com/clojure/tools.deps.alpha/blob/master/src/main/clojure/clojure/tools/deps/alpha/specs.clj[specs], the output of running `resolve-deps`
* `.cpcache/<hash>.cp` - a classpath string, the output of `make-classpath`

where the `<hash>` is based on the config file paths, the resolve-aliases, and the classpath aliases.

The cached classpath file is used when:

* It exists
* It is newer than all `deps.edn` files

=== Installation files and directories

The `clojure` and `clj` scripts rely on several directories and optionally on several environment variables.

* Installation directory
** Created during installation
** Contents:
*** `bin/clojure` - main script
*** `bin/clj` - wrapper script for interactive repl use (uses `rlwrap`)
*** `deps.edn` - install level deps.edn file, with some default deps (Clojure, etc)
*** `example-deps.edn` - commented example that gets copied to `<config_dir>/deps.edn`
*** `libexec/clojure-scripts-X.Y.Z.jar` - uberjar invoked by `clojure` to construct classpaths
* Config directory
** Can be created to hold a deps.edn file that carries across installation upgrades and takes affect across projects
** Locations checked in this order:
*** If `$CLJ_CONFIG` is set, then use `$CLJ_CONFIG` (explicit override)
*** If `$XDG_CONFIG_HOME` is set, then use `$XDG_CONFIG_HOME/clojure` (follows Freedesktop conventions)
*** Else use `$HOME/.clojure`
** Contents:
*** `deps.edn` - user deps file, defines default Clojure version and provider defaults
* Cache directory
** Lazily created if `clojure` is invoked without a local `deps.edn` file. Locations checked in this order:
*** If `$CLJ_CACHE` is set, then use `$CLJ_CACHE` (explicit override)
*** If `$XDG_CACHE_HOME` is set, then use `$XDG_CACHE_HOME/clojure` (follows Freedesktop conventions)
*** Else use `config_dir/.cpcache`
* Project directory
** The current directory
** Contents:
*** `deps.edn` - optional project deps
*** `.cpcache` - project cache directory, same as the user-level cache directory, created if there is a `deps.edn`

== Examples

=== Running a REPL from anywhere

To start a repl, you can invoke the `clj` script from anywhere as long as your installation has put the script in your path. Presuming there is no `deps.edn` in the current directory, the `deps.edn` files in the install directory (which includes a default depenendency on Clojure) and the config directory (which starts empty) are used to build the classpath.

The classpath will be cached in the user-level cache directory (location as described in the Installation files and directories above), so after the first invocation this should be pretty fast.

=== Running a REPL and specifying libs from Maven

When you want to specify libraries, you'll need to create a `deps.edn` file in the current directory, for example:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
   org.clojure/core.async {:mvn/version "0.3.465"}
 }
}
----

Invoking `clj` will then use the install, config, and local `deps.edn` files, merge them together, build the classpath, download the dependencies if needed, and start the REPL using a classpath for those dependencies. The classpath will be cached under `./cpcache` so subsequent invocations will be faster.

=== Including a test source directory into your classpath

The primary project classpath will not include the test source directory, but you can add extra paths as modifications to the make-classpath step of the classpath construction. To do so, add an alias `:test` that includes the extra relative source path `"test"`:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.9.0"}
 }
 :aliases {
   :test {:extra-paths ["test"]}
 }
}
----

Apply that classpath modification and start a REPL by invoking `clj -C:test`.

=== Refer to a specific local jar on disk

Occasionally you may need to refer directly to a jar on disk that is not present in a Maven repository. One common example is a database driver jar that is not distributed via Maven.

Local jar dependencies can be specified by using a local coordinate with the key `:local/root`. The local artifact provider will detect that this refers to a specific file.

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.9.0-beta2"}
   oracle/driver {:local/root "/path/to/oracle/driver.jar"}
 }
}
----

=== Refer to a local project on disk with a deps.edn file

You can also refer to local projects that have not been published to any Maven repository or built into a jar. This can be used to create a network of projects that are still in development. 

In this case you refer to the local root directory rather than a particular file. The local artifact provider will automatically detect the manifest file (deps.edn) in that directory and use it to determine the project's dependencies, which may either be local or Maven-based:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.9.0-beta2"}
   my.company/sibling-project {:local/root "/path/to/project"}
 }
}
----

Support for other manifest file types (pom.xml, project.clj, etc) are future possible extensions.

=== Running a Clojure namespace in the current directory

When you invoke `clojure` or `clj`, the classpath is built and `clojure.main` is invoked. `clojure.main` has support for loading a namespace and invoking it's `-main` function with arguments:

`clojure -m my.app 1 2 3`

=== Add an optional dependency to your classpath

Aliases in the `deps.edn` file can also be used to add optional dependencies that affect the classpath:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}
 }
}
----

Here the `:bench` alias is used to add an extra dependency, namely the criterium benchmarking library.

You can add this dependency to your classpath by adding the `:bench` alias to modify the dependency resolution: `clj -R:bench`.

=== Add an optional dependency and override a dependency

You can use multiple aliases in combination. For example this `deps.edn` file defines two aliases - `:1.9` to force the use of a particular Clojure version and `:bench` to add an extra dependency:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
   :bench {:extra-deps {criterium {:mvn/version "0.4.4"}}}
 }
}
----

Activate both aliases as follows: `clj -R:bench:1.9`

=== Override a classpath source

After dependency resolution, the classpath is constructed. You can modify this step to choose a different source for an artifact by using `:classpath-overrides`:

[source,clojure]
----
;; deps.edn
{:deps {
   org.clojure/clojure {:mvn/version "1.8.0"}
 }
 :aliases {
   :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
   :dev {:classpath-overrides {org.clojure/clojure "/Users/me/code/clojure/target/classes"}}
 }
}
----

The `:1.9` alias is a dependency resolution modification and the `:dev` alias is a classpath modification. Use them both together with: `clj -R:1.9 -C:dev`

=== Show classpath

In most of the previous examples we were starting a REPL or running a Clojure program. You can also use `-Spath` to just print the computed classpath and exit:

`clj -Spath`

Note that `-S` can be used in combination with other `clj` options as well.

== Connecting to S3 Maven repositories

The clj script includes support for connecting to private S3 Maven repositories (thanks to the https://github.com/s3-wagon-private/s3-wagon-private[s3-wagon-private] and https://github.com/spring-projects/aws-maven[aws-wagon] projects).

=== S3 repository

In your deps.edn file, include the s3 repository root:

[source,clojure]
----
{:deps {
   my.library {:mvn/version "0.1.2"}
 }
 :mvn/repos {
   "my-private-repo" {:url "s3://my-bucket/maven/releases"}
 }
}
----

=== S3 credentials

There are several ways to specify your AWS S3 credentials:

1. Set the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
2. Create a default profile in the AWS credentials file `~/.aws/credentials` (older `~/.aws/config` also supported).
3. Create a named profile in the AWS credentials file and set the environment variable `AWS_PROFILE` with its name.
4. Amazon ECS container and instance profile credentials should also work, but have not been tested.

For more information, most of the advice in http://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html[this AWS document] describes how credentials are located. Note however that the Java system properties options will NOT work with the clojure scripts (but would work if using the tools.deps.alpha library directly).
